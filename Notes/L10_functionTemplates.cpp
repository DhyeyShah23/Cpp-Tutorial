/* Including standard libraries */
#include <iostream>

using namespace std;



/* Function declarations */
void line(string);



/* Template Declarations */
template <typename T> T maximum(T, T);
template <typename T> const T& minimum(T, T);



/* Main function */
int main() {

// FUNCTION TEMPLATES
    line("FUNCTION TEMPLATES");

    /* 
    Function templates are used to create a function that can work with many different data types.
    The function template starts with the keyword template followed by the template parameter list, containing atleast 1 template parameter.
    Syntax: template <typename T> T function_name(T a, T b) {return (a > b)? a : b;}

    Function templates are just blueprints. They're not real cpp code consumed by the compiler.
    The compiler generates the actual code by looking at the arguments you call your function template with.
    The real cpp code thus generated is called a template instance.
    To see the template instance genration, visit the website: https://cppinsights.io
    A template instance is reused when a similar function call with the same argument types is issued. No duplicates are generated by the compiler.

    NOTE: Passing pointers in the below example will be diasterous.
    The compiler will compare which address is larger, not the values stored at those addresses, and hence, return the value accordingly, which can also be wrong.
    */

    int a {10}, b {20};
    double c {10.5}, d {20.5};
    string e {"Hello"}, f {"World"};

    auto res1 = maximum(a, b);              // int type deduced
    cout << res1 << endl;
    auto res2 = maximum(c, d);              // double type deduced
    cout << res2 << endl;
    auto res3 = maximum(e, f);              // string type deduced
    cout << res3 << endl;
    
    // auto res4 = maximum(a, c);           // Compilation will fail bcz it can't deduce the function type. To solve this, explicitly specify function type

    auto res5 = maximum<double>(c, d);      // Explicitly specify that we want double type called
    cout << res5 << endl;
    auto res6 = maximum<double>(a, c);      // There will be an implicit conversion from int to double
    cout << res6 << endl;
    // auto res7 = maximum<double>(a, e);   // Implicit conversion not possible, hhence the compilation will fail.

    // Passing value by reference
    auto res8 = minimum(a, b);
    cout << res8 << endl;



    
    line("PROGRAM END");
    return 0;
}



/* Function definations */
void line(string heading) {
    cout << endl;
    cout << "============= " << heading << " =============" << endl;
    cout << endl;
}



/* Template Definations */
template <typename T> T maximum(T a, T b) {             // Pass by value
    return ((a>b) ? a : b);
}

// Template specialization for const char* type
template <>
const char* maximum<const char*> (const char* a, const char* b) {       // We started with (const char*) bcz that's what we want our return type to be.
    return (std::strcmp(a, b) > 0) ? a : b;
}


template <typename T> const T& minimum(T a, T b) {      // Pass by reference
    return ((a<b ? a : b));
}